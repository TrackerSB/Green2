package bayern.steinbrecher.green2.launcher.utility;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.FileAttribute;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.tools.ToolProvider;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import bayern.steinbrecher.green2.sharedBasis.utility.IOStreamUtility;
import bayern.steinbrecher.javaUtility.XMLUtility;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * A class for handling upates and for checking conditions for applying these.
 *
 * @author Stefan Huber
 * @since 2u14
 */
public final class UpdateUtility {

    private static final Logger LOGGER = Logger.getLogger(UpdateUtility.class.getName());
    private static final FileAttribute<Set<PosixFilePermission>> ALL_PERMISSIONS
            = PosixFilePermissions.asFileAttribute(PosixFilePermissions.fromString("rwxrwxrwx"));
    private static final String UPDATE_CONDITIONS_PATH
            = PathUtility.PROGRAMFOLDER_PATH_ONLINE + "/updateConditions.xml";

    private UpdateUtility() {
        throw new UnsupportedOperationException("Construction of an object is not allowed.");
    }

    private static Optional<String> readOnlineUpdateConditions() {
        String updateConditions = null;
        try {
            updateConditions
                    = IOStreamUtility.readAll(new URL(UPDATE_CONDITIONS_PATH).openStream(), StandardCharsets.UTF_8);
        } catch (IOException ex) {
            LOGGER.log(Level.SEVERE, null, ex);
        }
        return Optional.ofNullable(updateConditions);
    }

    private static String createTestSource(String callableSource) {
        return "package test;\n"
                + "import java.util.concurrent.Callable;\n"
                + "\n"
                + "/**\n"
                + " * Generated by Green2 update validation.\n"
                + " */"
                + "public class Test {\n"
                + "    public static boolean test()throws Exception {\n"
                + "        Callable<Boolean> condition = " + callableSource + ";\n"
                + "        return condition.call();\n"
                + "    }\n"
                + "}\n";
    }

    private static Callable<Boolean> createTest(String source) {
        Callable<Boolean> test;
        try {
            Path tempDir = Files.createTempDirectory("green2UpdateCondition_", ALL_PERMISSIONS);
            tempDir.toFile().deleteOnExit();
            Path tempFile = Paths.get(tempDir.toString(), "test", "Test.java");
            tempFile.getParent().toFile().mkdirs();
            tempFile.toFile().createNewFile();
            Files.write(tempFile, createTestSource(source).getBytes(), StandardOpenOption.TRUNCATE_EXISTING);

            ToolProvider.getSystemJavaCompiler()
                    .run(null, null, null, tempFile.toString());

            URLClassLoader classLoader = URLClassLoader.newInstance(new URL[]{tempDir.toUri().toURL()});
            Method testMethod = Class.forName("test.Test", true, classLoader)
                    .getMethod("test");
            test = () -> (Boolean) testMethod.invoke(null);
        } catch (IOException | ClassNotFoundException | NoSuchMethodException ex) {
            LOGGER.log(Level.SEVERE, "Could not parse test.", ex);
            test = null;
        }
        return test;
    }

    /**
     * Returns a {@link Map} of checks to determine whether this computer sufficies all conditions to be met by a new
     * version of this application.
     *
     * @return A {@link Map} of checks of update conditions represented by mapping a name of a test to a
     * {@link Callable} performing the actual test.
     */
    public static Optional<Map<String, Callable<Boolean>>> getUpdateConditions() {
        return readOnlineUpdateConditions()
                .map(xml -> {
                    boolean parsedSucessfully = true;
                    Map<String, Callable<Boolean>> updateConditions = new HashMap<>();
                    try {
                        Optional<String> validation
                                = XMLUtility.isValidXML(xml, UpdateUtility.class.getResource("updateConditions.xsd"));
                        if (validation.isPresent()) {
                            LOGGER.log(Level.WARNING, "The given XML is not valid:\n{0}", validation);
                        } else {
                            DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
                            DocumentBuilder builder = builderFactory.newDocumentBuilder();
                            Document document
                                    = builder.parse(new ByteArrayInputStream(xml.getBytes(StandardCharsets.UTF_8)));
                            NodeList conditions = document.getElementsByTagName("condition");
                            for (int i = 0; i < conditions.getLength(); i++) {
                                Node condition = conditions.item(i);
                                NodeList conditionChildren = condition.getChildNodes();
                                Callable<Boolean> test = null;
                                String testName = null;
                                for (int j = 0; j < conditionChildren.getLength(); j++) {
                                    Node attribute = conditionChildren.item(j);
                                    switch (attribute.getNodeName()) {
                                        case "name":
                                            testName = attribute.getTextContent();
                                            break;
                                        case "function":
                                            test = createTest(attribute.getTextContent());
                                            break;
                                        case "#text":
                                            //These are contents of the direct children of a "condition" node
                                            break;
                                        default:
                                            //An unknown node is just ignored
                                            break;
                                    }
                                }
                                if (testName == null || test == null) {
                                    LOGGER.log(Level.SEVERE, "Found conditions with missing conditions or names.");
                                } else {
                                    updateConditions.put(testName, test);
                                }
                            }
                        }
                    } catch (SAXException | IOException | ParserConfigurationException ex) {
                        LOGGER.log(Level.SEVERE, null, ex);
                        parsedSucessfully = false;
                    }
                    return parsedSucessfully ? updateConditions : null;
                });
    }
}
